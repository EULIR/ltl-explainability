-- gas station system generated by gas_generator_script
-- by Stefano Tonetta (stonetta@dit.unitn.it)
--
-- This solution to the stack problem and the correspondent LTL
-- properties have been inspired by the work:
-- Matthew B. Dwyer, Corina S. Pasareanu. "Model Checking Generic
-- Container Implementations". Generic Programming 1998: 162-177 
--
-- StackMax_Size = 6

MODULE stub_process(obj_p)

MODULE main

DEFINE
push1 := callPushd1;
push2 := callPushd2;
push3 := callPusho;

pop1 := returnPopd1;
pop2 := returnPopd2;
pop3 := returnPopo;

pop := pop1 | pop2 | pop3;

call1 := callProcessd1;
call2 := callProcessd2;
call3 := callProcesso;

call23 := call2 | call3;

freeze := callTop_Down;

LTLSPEC
F (push1 & X (push2 & X (!pop U freeze))) -> G F (call2 & X call1)

VAR
  status: {Push,Pop,Empty,Top_Down,Null,Exit};
  StackTop: 0..6;
  StackActual : array 1..6 of {o,d1,d2};
  obj_in: {o,d1,d2}; 
  obj_out: {o,d1,d2}; 
  index: 0..6;
  sp: stub_process(obj_p);

IVAR
  choice: 1..8;
  
ASSIGN
  init(status):=Null;
  next(status):=
    case
      err: Exit;
      !change: status;
      choice in {1,2,3}: Push;
      choice=4: Pop;
      choice=5: Empty;
      choice=6: Top_Down;
      choice=7: Null;
      choice=8: Exit;
    esac;
  init(StackTop):=0;
  next(StackTop):=
    case
      change & choice in {1,2,3} & StackTop<6: StackTop + 1;
      change & choice=4 & StackTop>0: StackTop - 1;
      1: StackTop;
    esac;
  next(StackActual[1]):=
    case
      change & choice=1 & StackTop=0: d1;
      change & choice=2 & StackTop=0: d2;
      change & choice=3 & StackTop=0: o;
      1: StackActual[1];
    esac;
  next(StackActual[2]):=
    case
      change & choice=1 & StackTop=1: d1;
      change & choice=2 & StackTop=1: d2;
      change & choice=3 & StackTop=1: o;
      1: StackActual[2];
    esac;
  next(StackActual[3]):=
    case
      change & choice=1 & StackTop=2: d1;
      change & choice=2 & StackTop=2: d2;
      change & choice=3 & StackTop=2: o;
      1: StackActual[3];
    esac;
  next(StackActual[4]):=
    case
      change & choice=1 & StackTop=3: d1;
      change & choice=2 & StackTop=3: d2;
      change & choice=3 & StackTop=3: o;
      1: StackActual[4];
    esac;
  next(StackActual[5]):=
    case
      change & choice=1 & StackTop=4: d1;
      change & choice=2 & StackTop=4: d2;
      change & choice=3 & StackTop=4: o;
      1: StackActual[5];
    esac;
  next(StackActual[6]):=
    case
      change & choice=1 & StackTop=5: d1;
      change & choice=2 & StackTop=5: d2;
      change & choice=3 & StackTop=5: o;
      1: StackActual[6];
    esac;
  next(obj_in):=
    case
      choice=1: d1;
      choice=2: d2;
      choice=3: o;
      1: obj_in;
    esac;
  next(obj_out):=
    case
      choice=4 & StackTop=1: StackActual[1];
      choice=4 & StackTop=2: StackActual[2];
      choice=4 & StackTop=3: StackActual[3];
      choice=4 & StackTop=4: StackActual[4];
      choice=4 & StackTop=5: StackActual[5];
      choice=4 & StackTop=6: StackActual[6];
      1: obj_out;
    esac;
  init(index):=StackTop;
  next(index):=
    case
      status=Top_Down & index>1: index - 1;
      1: StackTop;
    esac;
  
DEFINE
  change:=!(status=Exit | status=Top_Down);
  obj_p:=
    case
      index=1: StackActual[1];
      index=2: StackActual[2];
      index=3: StackActual[3];
      index=4: StackActual[4];
      index=5: StackActual[5];
      index=6: StackActual[6];
      1: 0;
    esac;
  result:= StackTop=0;
  err:=
    change & 
    ((choice in {1,2,3} & StackTop=6) |
     (choice=4 & StackTop=0) |
     (choice=6 & StackTop=0));
  callPush:= status=Push;
  callPushd1:= status=Push & obj_in=d1;
  callPushd2:= status=Push & obj_in=d2;
  callPusho:= status=Push & obj_in=o;
  returnPop:= status=Pop;
  returnPopd1:= status=Pop & obj_out=d1;
  returnPopd2:= status=Pop & obj_out=d2;
  returnPopo:= status=Pop & obj_out=o;
  callTop_Down:= status=Top_Down;
  callEmpty:= status=Empty;
  returnEmptyFalse:= status=Empty & result=0;
  returnEmptyTrue:= status=Empty & result=1;
  callProcessd1:= status=Top_Down & obj_p=d1;
  callProcessd2:= status=Top_Down & obj_p=d2;
  callProcesso:= status=Top_Down & obj_p=o;
