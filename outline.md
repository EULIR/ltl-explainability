# Outline

- Abstract:
  - Motivation
    - Linear Temporal Logic is widely used to specify requirements in safety-critical systems
  - Problem
    - However, like many formal verification techniques, it is known to be unintuitive and error-prone for human practitioners to specify and validate.
  - Solution
    - In this paper, we provide a new timeline tool for visualizing LTL-based specifications, which is effective at intuitively representing a wide range of formulas
  - Method
    - Our tool generates timeline visualizations by translating LTL formulae to intermediate representations as Buchi automata and then omega-regular expressions, and finally simplifying and visualizing the expressions.
  - Contribution
    - We provide an algorithm for this visualization, a theoretical soundness analysis, and analyze its effectiveness with experimental benchmarks.
- Motivation:
  - Formal methods, and LTL are super useful. Used in:
    - Requirement specification in safety-critical system e.g. aerospace control
    - Design time model checking to on-board runtime verification
  - They are unintuitive and error prone [?]. There is a big need to make specification easier for humans in the loop. 
  - And there has been recent work toward this, such as NASA’s FRET, which uses structured natural language to bridge gap between natural language to formal semantics
  - However, LTL is literally timelines. So timeline visualization could be a great candidate for representing LTL formulas in an intuitive manner
  - In this paper, we propose a timeline visualization tool, using regular expressions, that is effective at intuitively representing a wide range of LTL-based formulas
- Definitions:
  - <https://spot.lre.epita.fr/concepts.html>
  - LTL formula [def from Fig 4 of [that survey paper](https://www.researchgate.net/profile/Kristin-Rozier/publication/222531608_Linear_Temporal_Logic_Symbolic_Model_Checking/links/59e1026aaca2724cbfdb6c0c/Linear-Temporal-Logic-Symbolic-Model-Checking.pdf)]
    - Should just cite sec 3.1.1 of that survey paper
    - a finite set Prop of atomic propositions
    - Boolean connectives: not, and, or, implies
      - phi := p | not phi1 | phi1 and phi2 | phi1 or phi2 | phi1 implies phi2
    - LTL temporal connectives
      - f := phi | X f1 | f1 U f2 | f1 R f2 | G f1 | F f1
  - Omega word/infinite run
    - an element r = (r0, r1, r2, ...) of S ^ omega
    - For LTL, each rt is used to describe the state of system at t, and S = phi
  - State-based Buchi Automaton - Sigma-BA = (Q, Sigma, delta, Q0, Acc)
    - Q finite set of states
    - Sigma - finite set called alphabet
    - delta : Q x Sigma -> Q [transition fn not available for every (q, sig)?]
    - Q0 initial state
    - Acc , subset of Q, set of accepting states
    - An omega-word is accepted iff it visits some accepting state infinitely often
    - For LTL, again, Sigma = phi
  - Regular expressions
    - regexp r := \eps | \emptyset | phi | r1 ^ r2 | r1 or r2 | r1 \* [^ used for concat]
    - omega-regexp w := r omega | r ^ w1 | w1 or w2
  - Timeline [is this a real thing or just a regexp visualization]
  - One or two examples, going from LTL -> BA -> Omega regexp -> Timeline
    - Say, G(p or Xp)
    - G (F a -> F b) if not too complicated, else G(F p)
- Algorithm
  - LTL formula → BA → Omega regex → simplification → Timeline
  - ba2wregex: BA -> Omega regex
    - Input: G, a Buchi automaton
    - Output: the omega-regexp recognized by it
    - let reduce\_dfa(G, v)
      - Input: G, a DFA and node v that is neither initial or final
      - Output: G’, a DFA with states = states(G) - \{v\}, recognizing the same regular language
      - for every u --r\_in→ v --r\_out→ w
        - If v has self-edge r\_loop
          - Replace edges with u-- r\_in r\_loop\* r\_out → w
        - Else replace edges with u -- r\_in r\_out → w
      - return the reduced graph
    - let dfa2regex (G, s, f)
      - Input: G, automaton digraph(?) with single init and final states s, f 
      - Output: regex corresponding to language of all paths from s to f
      - while interior vertex v exists:
        - reduce\_dfa(G, v)
        - combine any and all multi edges by union
      - return regexp of s->f 
    - let dfa2regex\_firstvisit(G, s, f)
      - Input: G, automaton digraph/DFA with single init and final states s, f 
      - Output: regex corresponding to all paths from s reaching f for the first time
      - delete all out edges from f in G
      - return dfa2regex(G, s, f)
    - % Let dfa2regex\_firstnonemptyyvisit(G, f)? [trying something unimportant]
    - return Union\_{f in F} (dfa2regex\_firstvisit(G, s, f)) ^ (dfa2regex (G, f, f) omega)
  - Simplification rewrite rules
    - 1. r e = e r => r
    - 2. (e + r) r\* = r\* (e + r) => r\*
    - 3. r1(r2 r3) => (r1 r2) r3
    - 4. r1 + r1r2\* => r1r2\*
    - 5. r1 + r2\*r1 => r2\*r1
    - 6. r1 + r1 => r1
    - 7. r1 + (r2 + r3) => (r1 + r2) + r3
    - 8. (ε + r)\* = (r + ε) => r\*
    - -
    - 9. (r\*)w = rw
    - 10. (r1r2\*)r2w = r1r2w
    - 11. r1\*r1w = r1w
    - 12. r1r1w = r1w
- Theorems
  - Correctness of algorithm
    - Thm 1. [done by SPOT] ltl2ba does what we want [what do we want?]
    - Thm 2.1. ba2wregex does its input to output behavior
      - Pf.
      - Theorem on Wikipedia?: An ω-language is recognized by a Büchi automaton if and only if it is an ω-regular language.
- For this we may want to show a specific version: 
- Let r1(q1, q2) be the regular expression that denotes starting from q1, the regular expression that reaches q2 for the first time
- Let r2(q1, q2) be the regular expression that denotes every path from q1 to q2
- Then the result is U\_{q \in start, q’ \in final} r1(q, q’) (r2(q’, q’) - {epsilon})w
  - Thm 2.2. reduce\_dfa(G, v) does its input to output behavior
    - Pf. 
  - Thm 2.2. dfa2regex(G, s, f) does its input to output behavior
    - Pf. 
      - By previous thm, for every interior vertex v, reduce\_dfa(G, v) preserves the regex of all (finite) paths from s to f
      - Also, combining multiedges, i.e. replacing edges u --r1→ w, u--r2→w with u--(r1|r2)--> w also clearly preserves the regex
      - While loop terminates as on every iteration, the number of interior edges decreases by 1, and when it ends, the reduced graph is simply [r1 loop]s--r2→ f[r4 loop] for some r (with self loops?)
  - Thm 2.3 dfa2regex\_firstvisit does its input to output behavior
    - Pf. 
  - Thm 3. All simplification rules preserve the omega regular language
  - Thm 4. Thus whole ltl2wregex maps to correct set of satisfying traces
  - More theorem ideas
    - Complexity of algorithm. We probably don’t care about this and it is probably not good but it seems like a thing people write about
    - Star height is always good, or sometimes bad. Would say something valuable about visualization feasibility if we could

- Tool showcase/Examples?
  - Random LTL formula demo was cool!!!
- Benchmark?
  - Table or plot: length of input ltl formula to length of output wregex
    - If we do as in MLTL paper (Figs 1-8), would need defns of length
- Future work
  - Forward chaining + maybe other rewrite ideas




# Intro/Motivation
Formal methods, including Linear Temporal Logic (LTL), are widely used in the specification and analysis of safety-critical systems, such as those found in the aerospace industry. These methods provide powerful tools for rigorously verifying the correctness of system designs, from early design-time model checking to on-board runtime verification. However, these methods can be difficult for humans to understand and use, leading to the possibility of errors and misunderstandings.

There has been recent work aimed at making the use of formal methods more intuitive for humans, such as NASA's FRET (Formal Requirements Engineering Tool) which uses structured natural language to bridge the gap between natural language and formal semantics. 

However, LTL is a literally a language of timelines, so timeline visualizations have the potential to be a powerful tool for representing LTL formulas in an intuitive manner. In this paper, we propose such a timeline visualization tool, using regular expressions, to effectively represent a wide range of LTL-based formulas. 
